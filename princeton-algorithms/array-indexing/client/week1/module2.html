<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <title>Princeton Algorithm</title>
    <script type="module" src="index.js"></script>
</head>

<body class="bg-dark text-white">
    <div class="container p-5 mb-2">
        <div>
            <h1>Module 2 - Algorithm by Princeton University</h1>
            <h2>Union-Find algorithm</h2>
            <p><strong>Union</strong> - connect two objects <br />
                <strong>Find/connected query</strong> - is there a path connecting the two objects?</p>
            <p><strong>Assumptions:</strong></p>
            <ul>
                <li>Reflexive: p is connected to p</li>
                <li>Symmetric: if p is connected to q, then q is connected to p</li>
                <li>Transitive: if p is connected to q and q is connected to r, then p is connected to r </li>
            </ul>
            <p>Union find data type api:</p>
            <pre>
            UF(int n); //initialize union find datastructure with n objects(0-N-1)
            void union(int p, int q) //add connection between p and q
            boolean connected(int p, int q) // are p and q in same component?
            int find(int p)
            int count()
        </pre>

            <p>Dynamic connectivity:</p>
            <pre>
            int n = StdIn.readInt();
            UF uf = new UF(n);
            while(!StdIn.isEmpty()){
                int p = StdIn.readInt();
                int q = StdIn.readInt();
                if(!u.connected(p,q)){
                    uf.union(p,q);
                    StdOut.println(p+ " " + q");
            }
        }
        </pre>

            <h3>Dynamic-connectivity client</h3>
            <ul>
                <li>Read in number of objects N from standard input</li>
                <li>read in pair of integers from standard input</li>
                <li>if they are not yet connected, connect them and print out pair</li>
            </ul>

            <h2>Quick find</h2>
            <p>p and q are connected iff they have same id</p>
            <pre>
        public boolean find(int p, int q){
            int n = id.length();
            int id[n];
            public boolean connected(){
                return id[p] == id[q];
            }
        }
        </pre>
            <p>Find : Check if p and q have same id </p>
            <p>Union : Merge components containing p and q, change all entries whose id equals ip[p] and id[q].
                After
                Union both id becomes equals</p>

            Below are the <b>APIs</b> that encapsulate an efficient Quick Find algorithm, designed for dynamic
            connectivity operations. These APIs will be utilized by a client program to manage and query the
            connectivity between elements. The role of the client is to invoke these APIs to perform
            operations such as union and find, thereby leveraging the encapsulated algorithm to determine and
            manipulate
            the connected components within the dataset.
            <br />
            <br />
            <p><b>What is Quick find?</b> <br />
                Quick Find is one of the simplest algorithms for solving the dynamic connectivity problem.</p>
            <b>Concept :</b>
            Quick Find uses an integer array id[] where id[i] is the identifier of the component containing i.
            Two
            elements p and q are connected if they have the same identifier
            <button class="btn btn-primary" id="button-1">Cick me</button>
            <div class="mt-3">
                Count: <span id="count-container"></span>
                <button class="btn btn-secondary" id="button-2">Increment!</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>